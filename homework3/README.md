## Препоръки

Нека разгледаме една опростена версия на социална мрежа. Какво имаме в нея:
- потребители, характеризиращи се само с име;
- приятелствата между потребителите, описани чрез граф - ребро в графа означава двупосочно приятелство между потребители

### Цел
Бихме искали да можем да помагаме на хората в нашата социална мрежа да "откриват" свои познати, които все още не са. За целта ще даваме предложения на потребител за хора, които може би познава с идеята да се сприятелява с тези хора в рамките на нашата (бъдеща) системата. Но как да определим кои хора да предлагаме?  
Все пак търсим хора, които е вероятно той да познава "по други линии". На този етап най-вероятно е това да са хора, които са приятели на негови приятели, но не и на него самия. Това важи и за приятели на приятели на неговите приятели, но колкото по далечни "приятели са", толкова вероятността да ги познава изглежда по-малка. От друга страна, колкото повече общи приятели има той с някого, толкова вероятността той да познава този човек е по-голяма.  

Нека дадем малко дефиниции:
- `близост на потребители` - това е число, такова че:
  - ако са приятели в мрежата, то близостта им е `0`;
  - ако не са, се определя от дължината най-късия път между двамата потребители през техните приятели. Това може да бъде изказано като "приятел на приятел, на приятел...". Например, приятел на приятел е със стойност `1`.
- `индиректен приятел` - това са потребители с `близост` > 0
- `приятелски коефициент` - това е число определящо до колко е вероятно даден потребител да се познава с този, на когото желаем да дадем предложения. Колкото по-близки `приятели/индиретни приятели` на нашия потребител A са приятели с даден потребител B, то толкова по-вероятно е потребителите А и B да се познават. Този коефициент е равен на броя `приятели/индиректни приятели` с 1-ца по-`близки` до "нашия" потребител A, спрямо близостта между текущо разглеждания B и потребител A (колко общи приятели на приятели има той с този приятел на приятел на приятел).

**Забележка 1**: вижте примера по-надолу - _един пример говори повече от хиляди думи_  
**Забележка 2**: винаги първо се предлагат потребители с по-малка `близост`, като реда на потребители с еднаква близост се определя от `приятеския коефициент`  
**Забележка 3**: ако един потребител няма приятели, да се спасява сам

### Какво се иска от нас?
Нека напишем външна функция, която по подаден `"граф на приятелствата"`, `човек` и `число` N връща списък от N предложения за приятели, сортирани първо по близостта до потребителя и второ по `приятески коефициент`.  

**Забележка 1\`:** Можете да използвате избрана от вас имплементация на Граф (задачата не изисква от вас да създавате своя такава)  
**Забележка 2\`:** Върнатият списък трябва да е от тип [`std::list`](https://en.cppreference.com/w/cpp/container/list). Ако вътрешно използвате друг контейнер, то по тривиален начин можете да създадете `std::list` от него

#### Пример:
Нека разгледам следния граф на приятелства. Търсим предложения за приятели на връх "0":
![Friends Graph example](https://github.com/danailbd/kn_sdp_2018/blob/master/homework3/resources/complex_graph_example.png)

Предложенията, които нашата функция би следвало да даде са както следва: `5 4 3 6 8 7 9 10 11`  
Като:
* `5 4 3 6` са с `близост` = 1; `8 7 9 10 11` са с `близост` = 2   
* `приятелските коефициенти`, са както следва:
  * за `5` е 3, тъй като потребител `0` има 3-ма общи **приятели** с него
  * за `4` е 2, защото `0` има 2-ма общи **приятели**
  * за `3` е `6` е 1, защото имат само по 1 общ **приятел** с него
  * за `8` също е 3, защото има 3-ма общи **приятели на приятели**
  * за `7`, `9`, `10` и `11` e 1, защото имат само по един общ **приятел на приятел**...

**Забележка 3**: Поредността на елементи от едно ниво с един и същ коефициент може да се приеме като случайна. В случая използваме естествената наредба на върховете в графа.


  
  
За улеснение са зададени и автоматизирани тестове, така че [дефинирайте функцията във вида, в който е зададена](https://github.com/danailbd/kn_sdp_2018/blob/master/homework3/main.cpp#L43). При желание можете да разширите тестовете с ваши.
