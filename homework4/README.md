## Hash your way
---

Вече се сдобихме с основни познания по контейнери работещи на принципа на `hash` и сега е време да си напишем такъв.
По-конкретно ще си напишем наш **HashMap**.

### Какво е HashMap?
**HashMap** е структура, която ни позволява да търсим елемент по ключ (който е например от тип "char * ") за много кратко време (гоним O(1) амортизирана сложност). Да, това е по-бързо дори и от двоично търсене, но къде е магията? Той се възползва от бързото достъпване на елемент на масив по индекс ( O(1) ) като за целта намира начин да сведе всяка стойност (например char * ) до число - индекс в масив. Тази стойност наричаме **hash**. В идеалния свят бихме имали безкрайно количество памет. Тогава бихме могли да дефинираме наистина уникални числа за всеки два различни стринга (char * ). Но ние сме ограничени в това отношение, затова ни се налага да предприемем други стъпки.
Нека дефинираме следните две стъпки:
- prehash(string key) - свежда ключът "key" до възможно най-уникален числов код
- hash(string key) - по добър начин вкарва по-уникалният "prehash" код в рамките на нашия ограничен контейнер

Нека забележим, че е възможно нашата хешираща функция да сведе два различни стринга, например "abb" и "bba" до един и същ код (**hash**). Това ще наричаме **колизия**. Ще се справяме с колизиите като използваме подхода "навързване" (chaining), който решава проблема като на всяка позиция в нашият контейнер съхранява списък от всички елементи, чиито код (hash) отговаря на тази позиция.

Ето малко връзки, с които да си помогнете:
- [добро обяснение](https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/)
- [string hash функции](https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1172/handouts/8-Hashing.pdf)
- [universal hash](https://en.wikipedia.org/wiki/Universal_hashing#Constructions)


#### Как трябва да изглежда нашият `HashMap` - основен публичен интерфейс:
- Трябва да е темлейтен и по двата си елемента - K, V. На този етап е да поддържаме ключ от типове int, char *
- `void add (K key, V value)` - добавя елемент в контейнера като за определяне на позиция, използва `key`
- `void remove (K key)` - премахва елемент
- `V get (K key)` - намира елемент по подаден ключ
- `int capacity ()` - текущият размер на контейнера
- `int size ()` - текущия брой елементи в нашият контейнер
- `int collisions ()` - брой колизии в нашият контейнер

**Какво още?**
- трябва да поддържа неограничено добавяне на елементи - да се преоразмерява сам, когато текущият капацитет е недостатъчен
    - ще се стараем размерът на контейнера да е поне около 30% по-голям от броя елементите в него.
- добре би било да имате различни *Hash* функции за различните типове
    - засега `int` и `char*` са достатъчни. Използвайте гореспоменатите връзки, за да намалите колизиите си

**Забележка 1**: При преоразмеряване, помислете какво трябва да се случи с текущите елементи в контейнера (rehash)  
**Забележка 2**: Поддържаме само уникални ключове. В случай на повтарящ се ключ (може `value`-то да е различно), презаписваме стойността  

Изплозвайте [този шаблон](https://github.com/danailbd/kn_sdp_2018/blob/master/homework4/main.cpp) като разпишете още тестове (поне 15 *assert*-a), за да обхванете по-голяма част от граничните случаи.  


П.П. Експериментирайте на воля с по-добри *hash* функции и наблюдавайте промяната по броя колизии. Допълнително можете да използвате и помощната [функция за засичане време на изпълнение](https://github.com/danailbd/kn_sdp_2018/blob/master/utils/elapseTime.cpp), за да наблюдавате промени по бързодействието на контейнера.  
П.П.2 В час реализирахме голяма част от проблема, така че не трябва да ви затрудни особено


#### More refs:
* hash & chaining - [MIT lecture](https://www.youtube.com/watch?v=0M_kIqhwbFo) 
* hash & chaining - [and notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec08.pdf)
